<!DOCTYPE html>
<html>
<head>
  <title>Todos/Goals</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/redux/3.7.2/redux.min.js"></script>
  <script src="https://unpkg.com/react@16.3.0-alpha.1/umd/react.development.js"></script>
  <script src="https://unpkg.com/react-dom@16.3.0-alpha.1/umd/react-dom.development.js"></script>
  <script src="https://unpkg.com/babel-standalone@6.15.0/babel.min.js"></script>
  <script src="https://tylermcginnis.com/goals-todos-api/index.js"></script>
</head>
<body>
  <div id="app"></div>

  <script type="text/javascript">
    function generateId () {
      return Math.random().toString(36).substring(2) + (new Date()).getTime().toString(36);
    }

    /* App Code */
    // ----------------------------------
    const ADD_TODO = 'ADD_TODO';
    const REMOVE_TODO = 'REMOVE_TODO';
    const TOGGLE_TODO = 'TOGGLE_TODO';
    const ADD_GOAL = 'ADD_GOAL';
    const REMOVE_GOAL = 'REMOVE_GOAL';
    const RECEIVE_DATA = 'RECEIVE_DATA';

    // Action creators
    function addTodoAction (todo) {
      return {
        type: ADD_TODO,
        todo,
      }
    }

    function removeTodoAction (id) {
      return {
        type: REMOVE_TODO,
        id,
      }
    }

    function toggleTodoAction (id) {
      return {
        type: TOGGLE_TODO,
        id,
      }
    }

    function addGoalAction (goal) {
      return {
        type: ADD_GOAL,
        goal,
      }
    }

    function removeGoalAction (id) {
      return {
        type: REMOVE_GOAL,
        id,
      }
    }

    function receiveDataAction (todos, goals) {
      return {
        type: RECEIVE_DATA,
        todos,
        goals,
      }
    }

    // 1. Custom Dispatch
    /*
    function checkAndDispatch (store, action) {
      ...
    }
    */

    // 2. The right way (middleware). [Curryng Functional Programming]
    const checker = (store) => (next) => (action) => {
      if (
        action.type === ADD_TODO &&
        ~action.todo.name.toLowerCase().indexOf('bitcoin')
      ) {
        return alert('Nope. That\'s a bad idea.');
      }

      if (
        action.type === ADD_GOAL &&
        ~action.goal.name.toLowerCase().indexOf('bitcoin')
      ) {
        return alert('Nope. That\'s a bad idea.');
      }

      return next(action);
    }

    // Another middleware
    const logger = (store) => (next) => (action) => {
      console.group(action.type);

      console.log('The action: ', action);
      const result = next(action);
      console.log('The new state: ', store.getState());

      console.groupEnd();

      return result;
    }

    // Reducer function (It must be a Pure Function)
    function todos (state = [], action) {
      switch (action.type) {
        case ADD_TODO:
          return state.concat([action.todo]);
        case REMOVE_TODO:
          return state.filter((todo) => todo.id !== action.id);
        case TOGGLE_TODO:
          return state.map((todo) => (
            todo.id !== action.id
            ? todo
            : Object.assign({}, todo, {complete: !todo.complete}))
          );
        case RECEIVE_DATA:
          return action.todos;
        default:
          return state;
      }
    }

    function goals (state = [], action) {
      switch(action.type) {
        case ADD_GOAL:
          return state.concat([action.goal]);
        case REMOVE_GOAL:
          return state.filter((goal) => goal.id !== action.id);
        case RECEIVE_DATA:
          return action.goals;
        default:
          return state;
      }
    }

    function app(state = {}, action) {
      return {
        todos: todos(state.todos, action),
        goals: goals(state.goals, action),
      };
    }

    // loading states | reducer
    function loading (state = true, action) {
      switch (action.type) {
        case RECEIVE_DATA:
          return false;
        default:
          return state;
      }
    }

    // const store = Redux.createStore(app);
    const store = Redux.createStore(Redux.combineReducers({
      todos,
      goals,
      loading,
    }), Redux.applyMiddleware(checker, logger));
  </script>

  <script type="text/babel">
    function List (props) {
      return (
        <ul>
          {
            props.items.map((item) => (
              <li key={item.id}>
                <span
                  onClick={() => props.toggle && props.toggle(item.id)}
                  style={{ textDecoration: item.complete ? 'line-through' : 'none' }}
                >
                  {item.name}
                </span>
                <button onClick={() => props.remove(item)}>âœ–</button>
              </li>
            ))
          }
        </ul>
      );
    }

    class Todos extends React.Component {
      addItem = (e) => {
        e.preventDefault();

        // Persisting Items
        return API.saveTodo(this.input.value)
          // Note: The ID is generated by the server.
          .then((todo) => { // "todo" is created by the server
            // What it means that We should delete the "generateId" function.
            this.props.store.dispatch(addTodoAction(todo));
            this.input.value = '';
          })
          .catch(() => alert('There was an error. Try again.'))
      }

      removeItem = (todo) => {
        // Optmistic updates | optimistically [deleting-toggling]
        /*
          It meaning we're going to remove the Todo item
          before we actually ever remove it from database.

          But If the request fails, meaning we tried to
          remove if from the database and something happens,
          there's network request or whatever, we need to
          go ahead and read that item back.
        */

        this.props.store.dispatch(removeTodoAction(todo.id));

        return API.deleteTodo(todo.id)
          .catch(() => {
            this.props.store.dispatch(addTodoAction(todo));

            alert('An error ocurred. Try again.');
          });
      }

      toggleItem = (id) => {
        // Optmistic updates | optimistically [deleting-toggling]
        this.props.store.dispatch(toggleTodoAction(id));

        return API.saveTodoToggle(id)
          .catch(() => {
            this.props.store.dispatch(toggleTodoAction(id));

            alert('An error ocurred. Try Again.');
          });
      }

      render() {
        return (
          <div>
            TODOS

            <h1>Todo List</h1>
            <input
              type="text"
              placeholder="Add Todo"
              ref={(input) => this.input = input}
            />
            <button onClick={this.addItem}>Add Todo</button>

            <List
              toggle={this.toggleItem}
              items={this.props.todos}
              remove={this.removeItem}
            />
          </div>
        );
      }
    }

    class Goals extends React.Component {
      addItem = (e) => {
        e.preventDefault();

        // Persisting Items
        return API.saveGoal(this.input.value)
          .then((goal) => {
            this.props.store.dispatch(addGoalAction(goal));
            this.input.value = '';
          })
          .catch(() => {
            alert('An error ocurred. Try again.');
          });
      }

      removeItem = (goal) => {
        // Optmistic updates | optimistically [deleting-toggling]
        /*
          We remove it locally, so the user gets that instant feedback.
        */
        this.props.store.dispatch(removeGoalAction(goal.id));

        return API.deleteGoal(goal.id)
          .catch(() => {
            this.props.store.dispatch(addGoalAction(goal));

            alert('An error ocurred. Try again.');
          });
      }

      render() {
        return (
          <div>
            GOALS

            <h1>Goals</h1>
            <input
              type="text"
              placeholder="Add Goal"
              ref={(input) => this.input = input}
            />
            <button onClick={this.addItem}>Add Goal</button>

            <List
              items={this.props.goals}
              remove={this.removeItem}
            />
          </div>
        );
      }
    }

    class App extends React.Component {
      componentDidMount() {
        const { store } = this.props;

        // These apis come from goals-todos-api script
        // handling initial data
        Promise.all([
          API.fetchTodos(),
          API.fetchGoals(),
        ]).then(([ todos, goals ]) => {
          store.dispatch(receiveDataAction(todos, goals));
        });

        store.subscribe(() => this.forceUpdate());
      }

      render() {
        const { store } = this.props;
        const { todos, goals, loading } = store.getState();

        // loading states
        if (loading === true) {
          return <h3>Loading</h3>;
        }

        return (
          <div>
            <Todos todos={todos} store={this.props.store} />
            <Goals goals={goals} store={this.props.store} />
          </div>
        );
      }
    }

    ReactDOM.render(
      <App store={store} />,
      document.getElementById('app')
    );
  </script>
</body>
</html>